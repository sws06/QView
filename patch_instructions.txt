FILE: gui.py
START_TAG:         self.details_outer_frame.grid_rowconfigure(1, weight=1) # Image display
        self.details_outer_frame.grid_rowconfigure(2, weight=1) # Notes section
END_TAG:         self.edit_save_note_button.grid(row=1, column=0, columnspan=2, pady=(5,0), sticky="e")
        # --- End Notes Frame ---
CONTENT:
        self.details_outer_frame.grid_rowconfigure(1, weight=1) # Image display
        # Note section is now a popup, row 2 configuration might not be needed or set to weight 0
        self.details_outer_frame.grid_rowconfigure(2, weight=0) 
---
FILE: gui.py
START_TAG:         self.view_bookmarks_button = ttk.Button(buttons_frame3, text=f"View Bookmarks ({len(self.bookmarked_posts)})", command=self.view_bookmarked_gui_posts)
        self.view_bookmarks_button.pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)
END_TAG:         self.view_bookmarks_button.pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)
CONTENT:
        self.view_bookmarks_button = ttk.Button(buttons_frame3, text=f"View Bookmarks ({len(self.bookmarked_posts)})", command=self.view_bookmarked_gui_posts)
        self.view_bookmarks_button.pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        self.view_edit_note_button = ttk.Button(buttons_frame3, text="View/Edit Note", command=self.show_note_popup, state=tk.DISABLED)
        self.view_edit_note_button.pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)
---
FILE: gui.py
START_TAG:         if hasattr(self, 'note_text_area'): self.note_text_area.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, selectbackground=tree_sel_bg)
END_TAG:         if hasattr(self, 'note_text_area'): self.note_text_area.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, selectbackground=tree_sel_bg)
CONTENT:
        # if hasattr(self, 'note_text_area'): self.note_text_area.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, selectbackground=tree_sel_bg) # Old embedded notes
---
FILE: gui.py
START_TAG:         if hasattr(self, 'note_text_area'): self.note_text_area.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, selectbackground=tree_sel_bg)
END_TAG:         if hasattr(self, 'note_text_area'): self.note_text_area.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, selectbackground=tree_sel_bg)
CONTENT:
        # if hasattr(self, 'note_text_area'): self.note_text_area.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, selectbackground=tree_sel_bg) # Old embedded notes
---
FILE: gui.py
START_TAG:         # --- Update User Note Area ---
        self.note_text_area.config(state=tk.NORMAL)
        self.note_text_area.delete(1.0, tk.END)
        # Use string representation of original_df_index for dictionary keys
        current_note = self.user_notes.get(str(original_df_index), "")
        if current_note:
            self.note_text_area.insert(tk.END, current_note)
        self.note_text_area.config(state=tk.DISABLED)
        self.edit_save_note_button.config(text="Edit Note", state=tk.NORMAL)
        # --- End Update User Note Area ---
END_TAG:         # --- End Update User Note Area ---
CONTENT:
        # --- Enable/Disable View/Edit Note button ---
        if hasattr(self, 'view_edit_note_button'):
            if self.df_displayed is not None and not self.df_displayed.empty and 0 <= self.current_display_idx < len(self.df_displayed):
                self.view_edit_note_button.config(state=tk.NORMAL)
            else:
                self.view_edit_note_button.config(state=tk.DISABLED)
        # --- End Enable/Disable ---
---
FILE: gui.py
START_TAG:         if hasattr(self, 'edit_save_note_button'): self.edit_save_note_button.config(state=tk.DISABLED)
        if hasattr(self, 'note_text_area'):
            self.note_text_area.config(state=tk.NORMAL); self.note_text_area.delete(1.0, tk.END)
            self.note_text_area.config(state=tk.DISABLED)
END_TAG:             self.note_text_area.config(state=tk.DISABLED)
CONTENT:
        if hasattr(self, 'view_edit_note_button'): self.view_edit_note_button.config(state=tk.DISABLED) # Changed from edit_save_note_button
        # No direct note_text_area in main UI anymore
---
FILE: gui.py
START_TAG:     # --- START USER_NOTES_METHODS ---
    def toggle_note_edit_mode(self):
        if self.df_displayed is None or self.df_displayed.empty or self.current_display_idx < 0:
            return

        original_df_index = str(self.df_displayed.index[self.current_display_idx]) # Use string key

        current_state = self.note_text_area.cget("state")
        if current_state == tk.DISABLED:
            self.note_text_area.config(state=tk.NORMAL)
            self.edit_save_note_button.config(text="Save Note")
            self.note_text_area.focus()
        else: # tk.NORMAL
            note_content = self.note_text_area.get(1.0, tk.END).strip()
            if note_content:
                self.user_notes[original_df_index] = note_content
            elif original_df_index in self.user_notes: # If content is empty, remove note
                del self.user_notes[original_df_index]
            
            self.note_text_area.config(state=tk.DISABLED)
            self.edit_save_note_button.config(text="Edit Note")
            # Notes are saved globally on closing, or could save immediately here:
            # utils.save_user_notes(self.user_notes, config.USER_NOTES_FILE_PATH)
            print(f"Note for post index {original_df_index} updated in memory.")
    # --- END USER_NOTES_METHODS ---
END_TAG:     # --- END USER_NOTES_METHODS ---
CONTENT:
    # --- START USER_NOTES_METHODS ---
    def show_note_popup(self):
        if self.df_displayed is None or self.df_displayed.empty or not (0 <= self.current_display_idx < len(self.df_displayed)):
            messagebox.showwarning("No Post Selected", "Please select a post to view or edit its note.", parent=self.root)
            return

        original_df_index = str(self.df_displayed.index[self.current_display_idx])
        current_note = self.user_notes.get(original_df_index, "")

        note_popup = tk.Toplevel(self.root)
        note_popup.title(f"Note for Post (Index: {original_df_index})")
        note_popup.geometry("500x400")
        note_popup.transient(self.root)
        note_popup.grab_set()

        try:
            dialog_bg = self.style.lookup("TFrame", "background")
            text_bg = self.style.lookup("TEntry", "fieldbackground")
            text_fg = self.style.lookup("TEntry", "foreground")
        except tk.TclError:
            dialog_bg = "#f0f0f0" if self.current_theme == "light" else "#2b2b2b"
            text_bg = "#ffffff" if self.current_theme == "light" else "#3c3f41"
            text_fg = "#000000" if self.current_theme == "light" else "#e0e0e0"
        
        note_popup.configure(bg=dialog_bg)

        popup_main_frame = ttk.Frame(note_popup, padding=10)
        popup_main_frame.pack(expand=True, fill=tk.BOTH)

        note_text_widget = tk.Text(popup_main_frame, wrap=tk.WORD, height=15, font=("TkDefaultFont", 10), relief=tk.SOLID, borderwidth=1, padx=5, pady=5)
        note_text_widget.configure(bg=text_bg, fg=text_fg, insertbackground=text_fg)
        note_text_widget.pack(expand=True, fill=tk.BOTH, pady=(0,10))
        note_text_widget.insert(tk.END, current_note)
        note_text_widget.focus_set()

        button_frame = ttk.Frame(popup_main_frame)
        button_frame.pack(fill=tk.X)

        def save_and_close():
            note_content = note_text_widget.get(1.0, tk.END).strip()
            if note_content:
                self.user_notes[original_df_index] = note_content
            elif original_df_index in self.user_notes: # If content is empty, remove note
                del self.user_notes[original_df_index]
            
            utils.save_user_notes(self.user_notes, config.USER_NOTES_FILE_PATH) # Save immediately
            print(f"Note for post index {original_df_index} saved.")
            note_popup.destroy()

        def cancel_and_close():
            note_popup.destroy()

        save_button = ttk.Button(button_frame, text="Save Note", command=save_and_close)
        save_button.pack(side=tk.RIGHT, padx=5)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=cancel_and_close)
        cancel_button.pack(side=tk.RIGHT)

        # Ensure popup stays on top and handles closing via window manager
        note_popup.protocol("WM_DELETE_WINDOW", cancel_and_close)
    # --- END USER_NOTES_METHODS ---